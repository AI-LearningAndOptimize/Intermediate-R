<!DOCTYPE html>
<html>
  <head>
    <title>Iterating with Functional Programming</title>
    <meta charset="utf-8">
    <link href="libs/font-awesome-animation/font-awesome-animation-emi.css" rel="stylesheet" />
    <script src="libs/fontawesome/js/fontawesome-all.min.js"></script>
    <link rel="stylesheet" href="scrollable.css" type="text/css" />
    <link rel="stylesheet" href="mtheme_max.css" type="text/css" />
    <link rel="stylesheet" href="fonts_mtheme_max.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: clear, center, middle

background-image: url("images/iterate-icon.jpg")
background-size: contain

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
.center.font200[with functional programming]

---
# Functional Programming

.pull-left[
&lt;br&gt;
.font150.center[

Iteration can be summed up as:

FOR EACH &lt;u&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/u&gt; DO &lt;u&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/u&gt;

]

]

--

.pull-right[

.center[You've probably done something like this with .bold.blue[copy &amp; paste]]


```r
df1 &lt;- readr::read_csv("data/Month-01.csv")
df2 &lt;- readr::read_csv("data/Month-02.csv")
df3 &lt;- readr::read_csv("data/Month-02.csv")
df4 &lt;- readr::read_csv("data/Month-03.csv")
df5 &lt;- readr::read_csv("data/Month-04.csv")
...
df11 &lt;- readr::read_csv("data/Month-11.csv")
```

&lt;br&gt;&lt;br&gt;
.center.bold[.content-box-gray[error prone &amp; inefficient]]

]

---
# Functional Programming

.pull-left[
&lt;br&gt;
.font150.center[

Iteration can be summed up as:

FOR EACH &lt;u&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/u&gt; DO &lt;u&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/u&gt;

]

]

.pull-right[

.center[You've probably done something like this with .bold.blue[.font120[`for`] loops]]


```r
for(i in list.files("data")) {
  # steps to import each data set
  df &lt;- readr::read_csv(paste0("data/", i))
  new_name &lt;- stringr::str_sub(i, end = -5)
  assign(new_name, df)
  rm(df)
}
```

&lt;br&gt;&lt;br&gt;
.center.bold[.content-box-gray[tough to focus on the intent]]

]

---
# Functional Programming

The intent of these approaches is 


&lt;img src="images/for-each.png" width="90%" height="90%" style="display: block; margin: auto;" /&gt;


---
# Functional Programming

Functional programming turns this idea into a function:

&lt;img src="images/fp-image1.png" width="90%" height="90%" style="display: block; margin: auto;" /&gt;

&lt;br&gt;

.center[.content-box-gray[which is more .bold.blue[efficient], .bold.blue[strict], and .bold.blue[explicit]!  .red.bold[But how?]]]


---
# Introducing the purrr package

.pull-left[

.font120[
The __purr__ package provides functional programming tools that:

1. for each element of x

2. apply function f and

3. provide consistent output

]
]

.pull-right[

&lt;img src="https://github.com/rstudio/hex-stickers/blob/master/PNG/purrr.png?raw=true" width="60%" height="60%" style="display: block; margin: auto;" /&gt;

]

&lt;br&gt;

.center[.content-box-gray[Disclaimer: __purrr__ is part of the tidyverse: https://purrr.tidyverse.org/]]

---
# Prerequisites

.pull-left[

### Package requirements


```r
library(tidyverse)
```

]

--

.pull-right[
First introductions to __purrr__ typically revolve around the family of .font120.bold.red[`map()`] functions:


```r
lsf.str("package:purrr", pattern = "^map")
## map : function (.x, .f, ...)  
## map_at : function (.x, .at, .f, ...)  
## map_call : function (.x, .f, ...)  
## map_chr : function (.x, .f, ...)  
## map_dbl : function (.x, .f, ...)  
## map_df : function (.x, .f, ..., .id = NULL)  
## map_dfc : function (.x, .f, ...)  
## map_dfr : function (.x, .f, ..., .id = NULL)  
## map_if : function (.x, .p, .f, ...)  
## map_int : function (.x, .f, ...)  
## map_lgl : function (.x, .f, ...)  
## map2 : function (.x, .y, .f, ...)  
## map2_chr : function (.x, .y, .f, ...)  
## map2_dbl : function (.x, .y, .f, ...)  
## map2_df : function (.x, .y, .f, ..., .id = NULL)  
## map2_dfc : function (.x, .y, .f, ...)  
## map2_dfr : function (.x, .y, .f, ..., .id = NULL)  
## map2_int : function (.x, .y, .f, ...)  
## map2_lgl : function (.x, .y, .f, ...)
```

]

---
# Basics of the .font120.red[`map()`] functions

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[`map( .x, .f, ...)`]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]


* .font120.bold[`.x`]: input (vector, data frame, or list)

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

&lt;br&gt;

&lt;img src="images/map-arg.png" width="1196" style="display: block; margin: auto;" /&gt;

]

---
# The .red[inputs]

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[.opacity20[`map( `]`.x`.opacity20[`, .f, ...)`]]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]

.font120[
* .font120.bold[`.x`]: input (&lt;u&gt;vector&lt;/u&gt;, data frame, or list)
]

]

.pull-right[

When our input is a .red.bold[vector]


```r
map(vector, function)
```

&lt;img src="images/fp-vector-inputs.png" width="2204" style="display: block; margin: auto;" /&gt;

]

---
# The .red[inputs]

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[.opacity20[`map( `]`.x`.opacity20[`, .f, ...)`]]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]

.font120[
* .font120.bold[`.x`]: input (vector, &lt;u&gt;data frame&lt;/u&gt;, or list)
]

]

.pull-right[

When our input is a .red.bold[data frame]


```r
map(vector, function)
```

&lt;img src="images/fp-dataframe-inputs.png" width="2347" style="display: block; margin: auto;" /&gt;

]

---
# The .red[inputs]

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[.opacity20[`map( `]`.x`.opacity20[`, .f, ...)`]]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]

.font120[
* .font120.bold[`.x`]: input (vector, data frame, or &lt;u&gt;list&lt;/u&gt;)
]

]

.pull-right[

When our input is a .red.bold[list]


```r
map(vector, function)
```

&lt;img src="images/fp-list-inputs.png" width="2439" style="display: block; margin: auto;" /&gt;

]

---
class: yourturn
# Give me some examples!

.pull-left[

Run the following examples in your console.  Don't worry about understanding everything, but identify

1. what is the input of each map function,

2. what is the output of each map function, and

3. talk to your neighbor about what you think each function is doing.

&lt;br&gt;

.center[.content-box-gray[Note how .font120[`purrr::map()`] is .font120[`%&gt;%`] friendly.]]

]

.pull-right[


```r
# 1.
iris %&gt;% map(n_distinct)

# 2.
input &lt;- c(1, 5, 10)
input %&gt;% map(runif, min = 1, max = 2)

# 3.
input %&gt;% map(~ sample(1:10, size = .x, replace = TRUE))
```

]

---
class: yourturn
# Give me some examples!

.pull-left[

1. inputs:
   1. data frame
   2. vector
   3. list

2. outputs: by default `map()` consistently returns a list (we'll come back to this shortly)
   
3. functions applied: 
   1. `n_distinct(.x)`
   2. `runif(.x, min = 1, max = 2)`
   3. `sample(1:10, size = .x, replace = TRUE)`
   

.center[___Note the different ways we can call a function!___]


]

.pull-right[


```r
# 1.
iris %&gt;% map(n_distinct)

# 2.
input &lt;- c(1, 5, 10)
input %&gt;% map(runif, min = 1, max = 2)

# 3.
input %&gt;% map(~ sample(1:10, size = .x, replace = TRUE))
```

]

---
# The .red[function call]

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

&lt;br&gt;

We can make function calls in different ways:


```r
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)
```

]

---
# The .red[function call]

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

&lt;br&gt;

We can make function calls in different ways:


```r
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)

# same as above but supplying additional parameters
map(input, runif, min = 1, max = 2)
```

]

---
# The .red[function call]

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

&lt;br&gt;

We can make function calls in different ways:


```r
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)

# same as above but supplying additional parameters
map(input, runif, min = 1, max = 2)

# anonymous function defined using formula shortcut
# handy when .x is not first argument
map(input, ~ sample(1:10, size = .x, replace = TRUE))
```

]

---
# The .red[function call]

.pull-left[

&lt;br&gt;
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of &lt;u&gt;.x&lt;/u&gt; do &lt;u&gt;.f&lt;/u&gt;]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

&lt;br&gt;

We can make function calls in different ways:


```r
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)

# same as above but supplying additional parameters
map(input, runif, min = 1, max = 2)

# anonymous function defined using formula shortcut
# handy when .x is not first argument
map(input, ~ sample(1:10, size = .x, replace = TRUE))

# traditional approach to apply anonymous function
*# TOO VERBOSE!
map(input, function(x) sample(1:10, size = .x, replace = TRUE))
```

]

---
class: yourturn
# Your Turn!

.pull-left[

Remember how `list.files("data")` shows all the .csv files?  See if you can:

1. combine `list.files("data")` and `paste0("data/", ...)` to create the following inputs:
    
    ```
    ##  [1] "data/Month-01.csv" "data/Month-02.csv" "data/Month-03.csv"
    ##  [4] "data/Month-04.csv" "data/Month-05.csv" "data/Month-06.csv"
    ##  [7] "data/Month-07.csv" "data/Month-08.csv" "data/Month-09.csv"
    ## [10] "data/Month-10.csv" "data/Month-11.csv"
    ```
2. now use this input vector, `map()`, and `read_csv()` to import all the data files into a list
  

]

---
class: yourturn
# Your Turn!

.scrollable90[
.pull-left[

Remember how `list.files("data")` shows all the .csv files?  See if you can:

1. combine `list.files("data")` and `paste0("data/", ...)` to create the following inputs:
    
    ```
    ##  [1] "data/Month-01.csv" "data/Month-02.csv" "data/Month-03.csv"
    ##  [4] "data/Month-04.csv" "data/Month-05.csv" "data/Month-06.csv"
    ##  [7] "data/Month-07.csv" "data/Month-08.csv" "data/Month-09.csv"
    ## [10] "data/Month-10.csv" "data/Month-11.csv"
    ```
2. now use this input vector, `map()`, and `read_csv()` to import all the data files into a list
   
]

.pull-right[


```r
list.files("data") %&gt;% 
  paste0("data/", .) %&gt;%
  map(read_csv)
## [[1]]
## # A tibble: 54,535 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1          5 2009-01-08 00:16:41        2        6 VI             20
##  2         16 2009-01-20 22:40:08        2        6 VI             20
##  3         28 2009-01-19 13:24:55        2        6 VI             21
##  4         40 2009-01-05 16:10:58        2        6 VI             20
##  5         62 2009-01-21 19:13:13        2        6 VI             20
##  6         64 2009-01-01 18:53:02        7        6 MC             20
##  7         69 2009-01-08 00:15:19        2        6 VI             20
##  8         69 2009-01-19 09:33:22        2        6 VI             20
##  9         70 2009-01-05 12:07:47        2        6 VI             20
## 10         79 2009-01-07 19:41:18        7        6 MC             20
## # … with 54,525 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[2]]
## # A tibble: 44,380 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1          3 2009-02-21 23:23:47        2        6 VI             20
##  2          7 2009-02-14 11:35:42        2        6 VI             20
##  3         17 2009-02-04 10:55:54        2        6 VI             20
##  4         21 2009-02-26 09:33:05        2        6 VI             20
##  5         24 2009-02-12 10:35:55        2        6 VI             20
##  6         24 2009-02-23 11:12:04        2        6 VI             20
##  7         24 2009-02-23 16:31:24        2        6 VI             20
##  8         24 2009-02-24 05:52:17        2        6 VI             20
##  9         24 2009-02-24 18:00:51        2        6 VI             20
## 10         24 2009-02-25 07:03:45        2        6 VI             20
## # … with 44,370 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[3]]
## # A tibble: 53,259 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1          3 2009-03-09 00:12:28        2        6 VI             20
##  2         12 2009-03-01 08:31:28        8       18 AX             20
##  3         24 2009-03-01 08:12:31        2        6 VI             20
##  4         24 2009-03-01 21:11:28        2        6 VI             20
##  5         24 2009-03-02 09:22:40        2        6 VI             20
##  6         36 2009-03-24 00:41:44        2        6 VI             20
##  7         41 2009-03-11 12:02:39        8       18 AX             20
##  8         45 2009-03-03 09:07:40        2        6 VI             20
##  9         55 2009-03-01 16:22:52        7       15 MC             20
## 10         68 2009-03-12 14:38:26        2        6 VI             25
## # … with 53,249 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[4]]
## # A tibble: 51,033 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1          8 2009-04-19 15:25:35        2        6 VI             20
##  2          8 2009-04-29 13:46:18        2        6 VI             20
##  3          9 2009-04-16 12:36:41        8       18 AX             20
##  4         19 2009-04-27 23:07:43        2        6 VI             20
##  5         25 2009-04-04 18:40:35        2        6 VI             20
##  6         25 2009-04-17 16:10:23        2       18 VI             20
##  7         25 2009-04-20 11:13:08        2        6 VI             20
##  8         25 2009-04-27 16:19:17        2        6 VI             20
##  9         28 2009-04-02 16:16:18        2        6 VI             21
## 10         42 2009-04-09 15:54:05        8       18 AX             20
## # … with 51,023 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[5]]
## # A tibble: 55,079 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1         13 2009-05-28 21:58:48        8       18 AX             20
##  2         14 2009-05-10 00:13:13        2        6 VI             20
##  3         25 2009-05-09 18:15:11        2        6 VI             20
##  4         43 2009-05-13 12:09:34        8       18 AX             20
##  5         61 2009-05-08 21:39:52        7       15 MC             20
##  6         63 2009-05-16 16:47:49        2        6 VI             20
##  7         63 2009-05-28 10:42:34        2        6 VI             20
##  8         67 2009-05-25 16:42:46        7       15 MC             20
##  9         71 2009-05-11 13:11:47        8       18 AX             20
## 10         89 2009-05-14 23:14:11        8       18 AX             20
## # … with 55,069 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[6]]
## # A tibble: 59,666 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1         15 2009-06-02 15:54:21        8       18 AX             20
##  2         43 2009-06-27 06:28:36        8       23 AX             21
##  3         73 2009-06-01 14:51:09        8       18 AX             20
##  4         78 2009-06-22 09:48:51        2        6 VI             20
##  5         82 2009-06-15 18:00:55        2        6 VI             20
##  6        106 2009-06-20 17:06:08        7       15 MC             20
##  7        106 2009-06-21 14:25:33        7       15 MC             20
##  8        124 2009-06-19 13:45:24        2        6 VI             25
##  9        133 2009-06-24 07:30:27        2        6 VI             20
## 10        138 2009-06-05 19:12:54        8       18 AX             20
## # … with 59,656 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[7]]
## # A tibble: 64,268 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1          1 2009-07-13 19:08:50        8       23 AX             21
##  2         10 2009-07-27 01:38:10        7       15 MC             20
##  3         26 2009-07-13 10:58:51        8       23 AX             21
##  4         33 2009-07-19 11:03:08        2        6 VI             20
##  5         34 2009-07-29 18:52:02        2        6 VI             20
##  6         53 2009-07-11 14:05:26        2        6 VI             20
##  7         53 2009-07-27 00:15:00        2        6 VI             20
##  8         57 2009-07-09 09:32:24        7       15 MC             20
##  9         66 2009-07-30 12:02:44        2        6 VI             20
## 10         85 2009-07-10 14:49:25        8       23 AX             21
## # … with 64,258 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[8]]
## # A tibble: 69,492 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1          4 2009-08-17 14:20:06        8       23 AX             21
##  2          6 2009-08-31 17:33:42        2        6 VI             25
##  3         22 2009-08-04 11:23:11        8       23 AX             26
##  4         22 2009-08-11 12:44:38        8       23 AX             26
##  5         32 2009-08-15 14:14:42        8       23 AX             21
##  6         37 2009-08-18 20:16:04        7       15 MC             20
##  7         49 2009-08-20 21:56:11        2        6 VI             20
##  8         56 2009-08-26 17:25:55        2        6 VI             20
##  9         60 2009-08-17 12:40:48        2        6 VI             20
## 10         81 2009-08-24 18:54:21        2        6 VI             20
## # … with 69,482 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[9]]
## # A tibble: 71,855 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1         38 2009-09-12 09:51:42       10        6 DI             20
##  2         44 2009-09-28 17:04:10        8       23 AX             21
##  3         46 2009-09-13 14:27:57        2        6 VI             20
##  4         47 2009-09-11 10:01:57       10        6 DI             20
##  5         48 2009-09-11 18:22:22        2        6 VI             20
##  6         48 2009-09-23 21:40:03        2        6 VI             20
##  7         54 2009-09-18 04:35:50        2        6 VI             20
##  8         59 2009-09-20 14:35:43       10        6 DI             20
##  9         72 2009-09-21 18:53:42        7       15 MC             20
## 10         72 2009-09-28 16:53:15        7       15 MC             20
## # … with 71,845 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[10]]
## # A tibble: 80,277 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1         11 2009-10-11 14:59:25        2        6 VI             20
##  2         20 2009-10-16 19:18:09       16        6 DI             20
##  3         25 2009-10-13 19:50:14        2        6 VI             20
##  4         35 2009-10-16 14:06:10        2        6 VI             20
##  5         38 2009-10-09 23:36:19       10        6 DI             20
##  6         44 2009-10-06 14:49:24        8       23 AX             21
##  7         51 2009-10-07 19:28:54        2        6 VI             20
##  8         58 2009-10-30 12:45:49        2        6 VI             20
##  9         73 2009-10-23 17:05:41       15       23 AX             21
## 10         75 2009-10-16 14:47:15        7       15 MC             20
## # … with 80,267 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
## 
## [[11]]
## # A tibble: 94,315 x 10
##    Account_ID Transaction_Timest… Factor_A Factor_B Factor_C Factor_D
##         &lt;int&gt; &lt;dttm&gt;                 &lt;int&gt;    &lt;int&gt; &lt;chr&gt;       &lt;int&gt;
##  1          2 2009-11-18 22:58:29        7       15 MC             20
##  2          2 2009-11-25 11:24:29        7       15 MC             50
##  3          2 2009-11-25 11:26:15        7       15 MC             50
##  4          2 2009-11-25 12:12:34        7       15 MC             20
##  5         19 2009-11-09 23:40:38        2        6 VI             20
##  6         23 2009-11-25 15:30:42       15       23 AX             21
##  7         27 2009-11-30 20:45:45        7       15 MC             20
##  8         29 2009-11-23 09:11:07       15       23 AX             21
##  9         44 2009-11-05 00:45:21       15       23 AX             21
## 10         52 2009-11-05 15:28:04        2        6 VI             25
## # … with 94,305 more rows, and 4 more variables: Factor_E &lt;chr&gt;,
## #   Response &lt;int&gt;, Transaction_Status &lt;chr&gt;, Month &lt;chr&gt;
```

]
]

---
# Different .font120.red[`map()`] functions for different .red[outputs]

&lt;br&gt;
* As previously mentioned, .font120[`map()`] returns a list, which makes it the most general of the “map” family because you can put anything in a list.

* It is ___inconvenient___ to return a list when a simpler data structure would do

* Alternative .font120[`map()`] variants include:

   - .font120[`map_dbl()`] returns a double vector 
   - .font120[`map_lgl()`] returns a logical vector 
   - .font120[`map_int()`] returns a integer vector 
   - .font120[`map_chr()`] returns a character vector
   - .font120[`map_df()`] returns a data frame

---
# A family of .font120.red[`map()`] functions

.scrollable90[
.pull-left[

* Its best to use the most restrictive function for the output

* Informative errors will let you know when a problem arises with your output

* You can always use `map()` to help debug the output error

]

.pull-right[

```r
# output is double
mtcars %&gt;% map_dbl(sd)
##         mpg         cyl        disp          hp        drat          wt 
##   6.0269481   1.7859216 123.9386938  68.5628685   0.5346787   0.9784574 
##        qsec          vs          am        gear        carb 
##   1.7869432   0.5040161   0.4989909   0.7378041   1.6152000

# output is integer
iris %&gt;% map_int(n_distinct)
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##           35           23           43           22            3

# output is logical
iris %&gt;% map_lgl(is.numeric)
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##         TRUE         TRUE         TRUE         TRUE        FALSE

# output is character
iris %&gt;% map_chr(is.character)
## Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
##      "FALSE"      "FALSE"      "FALSE"      "FALSE"      "FALSE"

# output is data frame
mtcars %&gt;% map_df(scale)
## # A tibble: 32 x 11
##       mpg    cyl    disp     hp   drat       wt   qsec     vs     am   gear
##     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1  0.151 -0.105 -0.571  -0.535  0.568 -0.610   -0.777 -0.868  1.19   0.424
##  2  0.151 -0.105 -0.571  -0.535  0.568 -0.350   -0.464 -0.868  1.19   0.424
##  3  0.450 -1.22  -0.990  -0.783  0.474 -0.917    0.426  1.12   1.19   0.424
##  4  0.217 -0.105  0.220  -0.535 -0.966 -0.00230  0.890  1.12  -0.814 -0.932
##  5 -0.231  1.01   1.04    0.413 -0.835  0.228   -0.464 -0.868 -0.814 -0.932
##  6 -0.330 -0.105 -0.0462 -0.608 -1.56   0.248    1.33   1.12  -0.814 -0.932
##  7 -0.961  1.01   1.04    1.43  -0.723  0.361   -1.12  -0.868 -0.814 -0.932
##  8  0.715 -1.22  -0.678  -1.24   0.175 -0.0278   1.20   1.12  -0.814  0.424
##  9  0.450 -1.22  -0.726  -0.754  0.605 -0.0687   2.83   1.12  -0.814  0.424
## 10 -0.148 -0.105 -0.509  -0.345  0.605  0.228    0.253  1.12  -0.814  0.424
## # … with 22 more rows, and 1 more variable: carb &lt;dbl&gt;
```
]
]

---
class: yourturn
# Your Turn!

.pull-left[
With the `airquality` data set, use the most appropriate map functions to answer these three questions:

1. how many `n_distinct` values are in each column?

2. are there any missing values in this data set?

3. what is the standard deviation for each variable?

]

--

.pull-right[


```r
# 1
airquality %&gt;% map_int(n_distinct)
##   Ozone Solar.R    Wind    Temp   Month     Day 
##      68     118      31      40       5      31

# 2 
airquality %&gt;% map_lgl(~ any(is.na(.x)))
##   Ozone Solar.R    Wind    Temp   Month     Day 
##    TRUE    TRUE   FALSE   FALSE   FALSE   FALSE

# 3
airquality %&gt;% map_dbl(sd, na.rm = TRUE)
##     Ozone   Solar.R      Wind      Temp     Month       Day 
## 32.987885 90.058422  3.523001  9.465270  1.416522  8.864520
```

]

---
# .red[ROAD].gray[`map()`]

You've been introduced to the main components of __purrr__ functional programming:

1. how functions work with different inputs (`.x`: vectors, data frames, lists)

2. how you can call functions (`.f`: name only, name + additional args, anonymous function)

3. how you can pre-specify your output

--

So, right now you probably fall in one of two camps:

.pull-left[

.center.bold[Experienced `for` loop user]

Switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form.

]

--

.pull-right[

.center.bold[New to iteration]

.center[
<span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1466642830/552/wtf.gif?1466642830" style="height:3em; width:auto; "/&gt;</span>
]
]

--

.center.red[
___Don't worry, the following 3 steps will provide you with a strategy to simplify___ 
]

---
# .red[ROAD].gray[`map()`]

Strategy

1. Do it for one element

2. Turn it into a recipe

3. Use `map_*()` to do it to all elements

---
# ROAD`map()`: .red[do it for one]

use Charlotte Wickham's approach to demonstrate strategy

---
# ROAD`map()`: .red[turn it into a recipe]

use Charlotte Wickham's approach to demonstrate strategy

---
# ROAD`map()`: .red[do it to all elements]

use Charlotte Wickham's approach to demonstrate strategy


---
class: yourturn
# Your Turn!

---
# But there are base R functionals?

talk about differences between purrr and apply family


---
# Whetting your appetite

demo `map2()` and `pmap()`


---
# Questions

&lt;br&gt;

&lt;img src="images/questions.png" width="450" height="450" style="display: block; margin: auto;" /&gt;
    </textarea>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
