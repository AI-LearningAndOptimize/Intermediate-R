---
title: "Iterating with Functional Programming"
output:
  xaringan::moon_reader:
    css: ["scrollable.css", "mtheme_max.css", "fonts_mtheme_max.css"]
    self_contained: false
    lib_dir: libs
    chakra: libs/remark-latest.min.js
    nature:
      ratio: '16:9'
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    seal: false   
---

```{r setup, include=FALSE, cache=FALSE}
# Set global R options
options(htmltools.dir.version = FALSE, servr.daemon = TRUE)

# Set global knitr chunk options
knitr::opts_chunk$set(
  fig.align = "center", 
  cache = TRUE,
  error = FALSE,
  message = FALSE, 
  warning = FALSE, 
  collapse = TRUE 
)

# set ggplot theme in case I do any plotting
library(ggplot2)
thm <- theme_bw()
theme_set(thm)
```

class: clear, center, middle

background-image: url("images/iterate-icon.jpg")
background-size: contain

<br><br><br><br><br><br><br><br><br><br><br><br><br><br>
.center.font200[with functional programming]

---
# Functional Programming

.pull-left[
<br>
.font150.center[

Iteration can be summed up as:

FOR EACH <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u> DO <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>

]

]

--

.pull-right[

.center[You've probably done something like this with .bold.blue[copy & paste]]

```{r eval=FALSE}
df1 <- readr::read_csv("data/Month-01.csv")
df2 <- readr::read_csv("data/Month-02.csv")
df3 <- readr::read_csv("data/Month-02.csv")
df4 <- readr::read_csv("data/Month-03.csv")
df5 <- readr::read_csv("data/Month-04.csv")
...
df11 <- readr::read_csv("data/Month-11.csv")
```

<br><br>
.center.bold[.content-box-gray[error prone & inefficient]]

]

---
# Functional Programming

.pull-left[
<br>
.font150.center[

Iteration can be summed up as:

FOR EACH <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u> DO <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u>

]

]

.pull-right[

.center[You've probably done something like this with .bold.blue[.font120[`for`] loops]]

```{r eval=FALSE}
for(i in list.files("data")) {
  # steps to import each data set
  df <- readr::read_csv(paste0("data/", i))
  new_name <- stringr::str_sub(i, end = -5)
  assign(new_name, df)
  rm(df)
}
```

<br><br>
.center.bold[.content-box-gray[tough to focus on the intent]]

]

---
# Functional Programming

The intent of these approaches is 


```{r echo=FALSE, out.width="90%", out.height="90%"}
knitr::include_graphics("images/for-each.png")
```


---
# Functional Programming

Functional programming turns this idea into a function:

```{r echo=FALSE, out.width="90%", out.height="90%"}
knitr::include_graphics("images/fp-image1.png")
```

<br>

.center[.content-box-gray[which is more .bold.blue[efficient], .bold.blue[strict], and .bold.blue[explicit]!  .red.bold[But how?]]]


---
# Introducing the purrr package

.pull-left[

.font120[
The __purr__ package provides functional programming tools that:

1. for each element of x

2. apply function f and

3. provide consistent output

]
]

.pull-right[

```{r echo=FALSE, out.width="60%", out.height="60%"}
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/master/PNG/purrr.png?raw=true")
```

]

<br>

.center[.content-box-gray[Disclaimer: __purrr__ is part of the tidyverse: https://purrr.tidyverse.org/]]

---
# Prerequisites

.pull-left[

### Package requirements

```{r message=TRUE, warning=TRUE}
library(tidyverse)
```

]

--

.pull-right[
First introductions to __purrr__ typically revolve around the family of .font120.bold.red[`map()`] functions:

```{r}
lsf.str("package:purrr", pattern = "^map")
```

]

---
# Basics of the .font120.red[`map()`] functions

.pull-left[

<br>
.center[.content-box-gray[.font200[`map( .x, .f, ...)`]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]


* .font120.bold[`.x`]: input (vector, data frame, or list)

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

<br>

```{r, echo=FALSE}
knitr::include_graphics("images/map-arg.png")
```

]

---
# The .red[inputs]

.pull-left[

<br>
.center[.content-box-gray[.font200[.opacity20[`map( `]`.x`.opacity20[`, .f, ...)`]]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]

.font120[
* .font120.bold[`.x`]: input (<u>vector</u>, data frame, or list)
]

]

.pull-right[

When our input is a .red.bold[vector]

```{r eval=FALSE}
map(vector, function)
```

```{r echo=FALSE}
knitr::include_graphics("images/fp-vector-inputs.png")
```

]

---
# The .red[inputs]

.pull-left[

<br>
.center[.content-box-gray[.font200[.opacity20[`map( `]`.x`.opacity20[`, .f, ...)`]]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]

.font120[
* .font120.bold[`.x`]: input (vector, <u>data frame</u>, or list)
]

]

.pull-right[

When our input is a .red.bold[data frame]

```{r eval=FALSE}
map(vector, function)
```

```{r echo=FALSE}
knitr::include_graphics("images/fp-dataframe-inputs.png")
```

]

---
# The .red[inputs]

.pull-left[

<br>
.center[.content-box-gray[.font200[.opacity20[`map( `]`.x`.opacity20[`, .f, ...)`]]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]

.font120[
* .font120.bold[`.x`]: input (vector, data frame, or <u>list</u>)
]

]

.pull-right[

When our input is a .red.bold[list]

```{r eval=FALSE}
map(vector, function)
```

```{r echo=FALSE}
knitr::include_graphics("images/fp-list-inputs.png")
```

]

---
class: yourturn
# Give me some examples!

.pull-left[

Run the following examples in your console.  Don't worry about understanding everything, but identify

1. what is the input of each map function,

2. what is the output of each map function, and

3. talk to your neighbor about what you think each function is doing.

<br>

.center[.content-box-gray[Note how .font120[`purrr::map()`] is .font120[`%>%`] friendly.]]

]

.pull-right[

```{r, eval=FALSE}
# 1.
iris %>% map(n_distinct)

# 2.
input <- c(1, 5, 10)
input %>% map(runif, min = 1, max = 2)

# 3.
input %>% map(~ sample(1:10, size = .x, replace = TRUE))
```

]

---
class: yourturn
# Give me some examples!

.pull-left[

1. inputs:
   1. data frame
   2. vector
   3. list

2. outputs: by default `map()` consistently returns a list (we'll come back to this shortly)
   
3. functions applied: 
   1. `n_distinct(.x)`
   2. `runif(.x, min = 1, max = 2)`
   3. `sample(1:10, size = .x, replace = TRUE)`
   

.center[___Note the different ways we can call a function!___]


]

.pull-right[

```{r, eval=FALSE}
# 1.
iris %>% map(n_distinct)

# 2.
input <- c(1, 5, 10)
input %>% map(runif, min = 1, max = 2)

# 3.
input %>% map(~ sample(1:10, size = .x, replace = TRUE))
```

]

---
# The .red[function call]

.pull-left[

<br>
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

<br>

We can make function calls in different ways:

```{r eval=FALSE}
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)
```

]

---
# The .red[function call]

.pull-left[

<br>
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

<br>

We can make function calls in different ways:

```{r eval=FALSE}
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)

# same as above but supplying additional parameters
map(input, runif, min = 1, max = 2)
```

]

---
# The .red[function call]

.pull-left[

<br>
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

<br>

We can make function calls in different ways:

```{r eval=FALSE}
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)

# same as above but supplying additional parameters
map(input, runif, min = 1, max = 2)

# anonymous function defined using formula shortcut
# handy when .x is not first argument
map(input, ~ sample(1:10, size = .x, replace = TRUE))
```

]

---
# The .red[function call]

.pull-left[

<br>
.center[.content-box-gray[.font200[.opacity20[`map( .x, `]`.f, ...`.opacity20[`)`]]

.font150[for each element of <u>.x</u> do <u>.f</u>]
]]

* .opacity20[.font120.bold[`.x`]: input (vector, data frame, or list)]

* .font120.bold[`.f`]: function to apply

* .font120.bold[`...`]: addtl parameters

]

.pull-right[

<br>

We can make function calls in different ways:

```{r eval=FALSE}
# function with default parameters, by default
# .x will go in as the first argument
map(input, runif)

# same as above but supplying additional parameters
map(input, runif, min = 1, max = 2)

# anonymous function defined using formula shortcut
# handy when .x is not first argument
map(input, ~ sample(1:10, size = .x, replace = TRUE))

# traditional approach to apply anonymous function
# TOO VERBOSE! #<< 
map(input, function(x) sample(1:10, size = .x, replace = TRUE))
```

]

---
class: yourturn
# Your Turn!

.pull-left[

Remember how `list.files("data")` shows all the .csv files?  See if you can:

1. combine `list.files("data")` and `paste0("data/", ...)` to create the following inputs:
    ```{r, echo=FALSE}
    list.files("data") %>% paste0("data/", .)
    ```
2. now use this input vector, `map()`, and `read_csv()` to import all the data files into a list
  

]

---
class: yourturn
# Your Turn!

.scrollable90[
.pull-left[

Remember how `list.files("data")` shows all the .csv files?  See if you can:

1. combine `list.files("data")` and `paste0("data/", ...)` to create the following inputs:
    ```{r, echo=FALSE}
    list.files("data") %>% paste0("data/", .)
    ```
2. now use this input vector, `map()`, and `read_csv()` to import all the data files into a list
   
]

.pull-right[

```{r}
list.files("data") %>% 
  paste0("data/", .) %>%
  map(read_csv)
```

]
]

---
# Different .font120.red[`map()`] functions for different .red[outputs]

<br>
* As previously mentioned, .font120[`map()`] returns a list, which makes it the most general of the “map” family because you can put anything in a list.

* It is ___inconvenient___ to return a list when a simpler data structure would do

* Alternative .font120[`map()`] variants include:

   - .font120[`map_dbl()`] returns a double vector 
   - .font120[`map_lgl()`] returns a logical vector 
   - .font120[`map_int()`] returns a integer vector 
   - .font120[`map_chr()`] returns a character vector
   - .font120[`map_df()`] returns a data frame

---
# A family of .font120.red[`map()`] functions

.scrollable90[
.pull-left[

* Its best to use the most restrictive function for the output

* Informative errors will let you know when a problem arises with your output

* You can always use `map()` to help debug the output error

]

.pull-right[
```{r}
# output is double
mtcars %>% map_dbl(sd)

# output is integer
iris %>% map_int(n_distinct)

# output is logical
iris %>% map_lgl(is.numeric)

# output is character
iris %>% map_chr(is.character)

# output is data frame
mtcars %>% map_df(scale)
```
]
]

---
class: yourturn
# Your Turn!

.pull-left[
With the `airquality` data set, use the most appropriate map functions to answer these three questions:

1. how many `n_distinct` values are in each column?

2. are there any missing values in this data set?

3. what is the standard deviation for each variable?

]

--

.pull-right[

```{r}
# 1
airquality %>% map_int(n_distinct)

# 2 
airquality %>% map_lgl(~ any(is.na(.x)))

# 3
airquality %>% map_dbl(sd, na.rm = TRUE)
```

]

---
# .red[ROAD].gray[`map()`]

You've been introduced to the main components of __purrr__ functional programming:

1. how functions work with different inputs (`.x`: vectors, data frames, lists)

2. how you can call functions (`.f`: name only, name + additional args, anonymous function)

3. how you can pre-specify your output

--

So, right now you probably fall in one of two camps:

.pull-left[

.center.bold[Experienced `for` loop user]

Switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form.

]

--

.pull-right[

.center.bold[New to iteration]

.center[
`r anicon::cia("https://emojis.slackmojis.com/emojis/images/1466642830/552/wtf.gif?1466642830", animate = FALSE, size = 3)`
]
]

--

.center.red[
___Don't worry, the following 3 steps will provide you with a strategy to simplify___ 
]

---
# .red[ROAD].gray[`map()`]

Strategy

1. Do it for one element

2. Turn it into a recipe

3. Use `map_*()` to do it to all elements

---
# ROAD`map()`: .red[do it for one]

use Charlotte Wickham's approach to demonstrate strategy

---
# ROAD`map()`: .red[turn it into a recipe]

use Charlotte Wickham's approach to demonstrate strategy

---
# ROAD`map()`: .red[do it to all elements]

use Charlotte Wickham's approach to demonstrate strategy


---
class: yourturn
# Your Turn!

---
# But there are base R functionals?

talk about differences between purrr and apply family


---
# Whetting your appetite

demo `map2()` and `pmap()`


---
# Questions

<br>

```{r questions-fp, echo=FALSE, out.height="450", out.width="450"}
knitr::include_graphics("images/questions.png")
```

