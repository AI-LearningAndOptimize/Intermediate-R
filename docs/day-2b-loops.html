<!DOCTYPE html>
<html>
  <head>
    <title>Iterating with Loops</title>
    <meta charset="utf-8">
    <link href="libs/font-awesome-animation/font-awesome-animation-emi.css" rel="stylesheet" />
    <script src="libs/fontawesome/js/fontawesome-all.min.js"></script>
    <link rel="stylesheet" href="scrollable.css" type="text/css" />
    <link rel="stylesheet" href="mtheme_max.css" type="text/css" />
    <link rel="stylesheet" href="fonts_mtheme_max.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: clear, center, middle

background-image: url(http://static1.squarespace.com/static/57d161dc20099eb4bb0ccc05/t/57d69e61414fb51a88bd4798/1523877244472/)
background-size: contain

---
# Intro

.font120[
Often, we need to execute repetitive code statements a particular number of times. Or, we may even need to execute code for an undetermined number of times until a certain condition no longer holds.
]

--

* .font130[`for`] loops: execute code for a prescribed number of times (Rule of üëç, 3x).

* .font130[`while`] &amp; .font130[`repeat`] loops: repeat code while condition holds

* .font130[`next`] &amp; .font130[`break`]: additional clauses to control flow

--

&lt;br&gt;

.center.bold[There are additional iterating functions which we'll learn about in the functional programming module]

---
# `for` loop: syntax

.pull-left[
.font120[
* For each element in sequence (1-100) perform some defined task
]
]

.pull-right[


```r
for(i in 1:100) {
  &lt;do stuff here with i&gt;
}
```

]

---
# `for` loop: syntax

.pull-left[
* For each element in sequence (1-100) perform some defined task

* .red[What will this .font120[`for`] loop do?]
]

.pull-right[


```r
for(i in 1:100) {
  &lt;do stuff here with i&gt;
}
```


```r
for (i in 2010:2017) {
  print(paste("The year is", i))
}
```
]

---
# `for` loop: syntax

.pull-left[
* For each element in sequence (1-100) perform some defined task

* .red[What will this .font120[`for`] loop do?]
]

.pull-right[


```r
for(i in 1:100) {
  &lt;do stuff here with i&gt;
}
```


```r
for (i in 2010:2017) {
  print(paste("The year is", i))
}
## [1] "The year is 2010"
## [1] "The year is 2011"
## [1] "The year is 2012"
## [1] "The year is 2013"
## [1] "The year is 2014"
## [1] "The year is 2015"
## [1] "The year is 2016"
## [1] "The year is 2017"
```
]

---
# `for` loop: sequence input

.pull-left[
* Often, the length of the sequence is determined by some pre-defined variable

* For example, say we have a variable .font120.blue[`x`] and we want to iterate over each element and do something

* We can do this two ways

]

.pull-right[


```r
*x &lt;- 2010:2017

# option 1
for(i in 1:length(x)) {
  &lt;do stuff here with i&gt;
}

# option 2
for(i in seq_along(x)) {
  &lt;do stuff here with i&gt;
}
```

]

&lt;br&gt;
.center.bold.red[Talk to your neighbor. Do you prefer one over the other? <span style=" display: -moz-inline-stack; display: inline-block; transform: rotate(0deg);">&lt;img src="https://emojis.slackmojis.com/emojis/images/1504806416/2885/thinking-face-rotating.gif?1504806416" style="height:2em; width:auto; "/&gt;</span>
]

---
# `for` loop: sequence input

.pull-left[
* Often, the length of the sequence is determined by some pre-defined variable

* For example, say we have a variable .font120.blue[`x`] and we want to iterate over each element and do something

* We can do this two ways

* But `seq_along(x)` is safer for edge cases where the sequence has length zero

]

.pull-right[


```r
x &lt;- c()

# option 1: executes although it shouldn't
for(i in 1:length(x)) {
  print(i)
}
## [1] 1
## [1] 0

# option 2: does not execute
for(i in seq_along(x)) {
  print(i)
}
```

]

&lt;br&gt;

.center.bold.red[Beware iterating over `1:length(x)`. This will fail in unhelpful ways if `x` has length 0]

---
# `for` loop: generating output

.pull-left[

* Often we are generating output from the `for` loop that we want to use later

* We can do this by either .bold.red[growing] or .bold.green[filling] the output

* Pre-allocating the output and .bold.green[filling] in the results is more efficient

]

.pull-right[

.code70[

```r
# Let's create 100 different vectors w/10,000 obs
means &lt;- seq(0, 100, by = 1)

# Growing the output
out &lt;- list()
system.time({
  for(i in seq_along(means)) {
    # generate data
    gen_data &lt;- rnorm(10000, means[[i]])
    # grow list output
    out &lt;- c(out, gen_data)
  }
})
##    user  system elapsed 
##   0.592   0.125   0.718


# Pre-allocating and filling
out &lt;- vector("list", length(means))
system.time({
  for(i in seq_along(means)) {
    # generate &amp; fill output
    out[[i]] &lt;- rnorm(10000, means[[i]])
  }
})
##    user  system elapsed 
##   0.071   0.000   0.072
```
]
]

---
class: yourturn
# Your Turn: Challenge

* We can see all data sets that we have in the "data" folder with `list.files()`

.code70[

```r
list.files("data")
##  [1] "Month-01.csv" "Month-02.csv" "Month-03.csv" "Month-04.csv"
##  [5] "Month-05.csv" "Month-06.csv" "Month-07.csv" "Month-08.csv"
##  [9] "Month-09.csv" "Month-10.csv" "Month-11.csv"
```
]

.pull-left[

* Say we wanted to import one of these files into R


```r
# here's a single file
(first_df &lt;- list.files("data")[1])
## [1] "Month-01.csv"

# create path and import this single file
df &lt;- readr::read_csv(paste0("data/", first_df))

# create a new name for file
(new_name &lt;- stringr::str_sub(first_df, end = -5))
## [1] "Month-01"

# dynamically rename file
assign(new_name, df)
```

]

--

.pull-right[

* Can you incorporate these procedures into a `for` loop to import all the data files?


```r
for(i in _____) {
  # 1: import data
  df &lt;- readr::read_csv(_____)
  
  # 2: remove ".csv" of name
  new_name &lt;- _____
  
  # 3: dynamically rename file
  assign(_____, _____)
}
```


]


---
class: yourturn
# Your Turn: Solution

.pull-left[

1. Import ith data file

2. Make a new name without ".csv" (i.e. "Month-01")

3. Dynamically rename file with `assign()`

4. Remove unnecessary duplicate

]

.pull-right[


```r
for(i in list.files("data")) {
  # 1: import data
  df &lt;- readr::read_csv(paste0("data/", i))
  
  # 2: remove ".csv" of name
  new_name &lt;- stringr::str_sub(i, end = -5)
  
  # 3: dynamically rename file
  assign(new_name, df)
  
  # 4: remove unnecessary object
  rm(df)
}
```

]

---
# Controlling sequences

.pull-left[

There are two ways to control the progression of a loop:

.font120[

* `next`: terminates the current iteration and advances to the next.

]
]

.pull-right[


```r
x &lt;- c(1, 2, NA, 3)

# use next to skip an iteration
for (i in x) {
* if (is.na(i)) next    # if NA don't execute

  print(i)
}
## [1] 1
## [1] 2
## [1] 3
```

]

---
# Controlling sequences

.pull-left[

There are two ways to control the progression of a loop:

* `next`: terminates the current iteration and advances to the next.

* `break`: exits the entire `for` loop.

]

.pull-right[


```r
x &lt;- c(1, 2, NA, 3)

# use next to skip an iteration
for (i in x) {
  if (is.na(i)) next

  print(i)
}
## [1] 1
## [1] 2
## [1] 3
```



```r
# use break to stop
for (i in x) {
* if (is.na(i)) break     # if NA stop!

  print(i)
}
## [1] 1
## [1] 2
```

]

--

.center.red[_both are used in conjunction with `if` statements_]

---
class: yourturn
# Your Turn: Challenge!

.pull-left[

The following code identifies the month of the data set:


```r
# data files
(data_files &lt;- list.files("data"))
##  [1] "Month-01.csv" "Month-02.csv" "Month-03.csv" "Month-04.csv"
##  [5] "Month-05.csv" "Month-06.csv" "Month-07.csv" "Month-08.csv"
##  [9] "Month-09.csv" "Month-10.csv" "Month-11.csv"

# extract month number
as.numeric(stringr::str_extract(data_files, "\\d+"))
##  [1]  1  2  3  4  5  6  7  8  9 10 11
```

]

--

.pull-right[

Modify the following `for` loop with a `next` or `break` statement to:

1. only import `Month-01` through `Month-07`
2. only import `Month-08` through `Month-10`


```r
# Modify this code chunk with you next/break statement
for(i in list.files("data")) {
  # steps to import each data set
  df &lt;- readr::read_csv(paste0("data/", i))
  new_name &lt;- stringr::str_sub(i, end = -5)
  assign(new_name, df)
  rm(df)
}
```


]

---
class: yourturn
# Your Turn: Solution!

.pull-left[

.center[\#1: only import `Month-01` through `Month-07`]





```r
for(i in list.files("data")) {
  
* # break if month is greater than 7; although
* # this requires knowledge of month order
* month &lt;- as.numeric(stringr::str_extract(i, "\\d+"))
* if(month &gt; 7) break
  
  # steps to import each data set
  df &lt;- readr::read_csv(paste0("data/", i))
  new_name &lt;- stringr::str_sub(i, end = -5)
  assign(new_name, df)
  rm(df)

}

# we've only imported months 1-7
ls(pattern = "Month")
## [1] "Month-01" "Month-02" "Month-03" "Month-04" "Month-05" "Month-06"
## [7] "Month-07"
```

]

.pull-right[

.center[\#2: only import `Month-08` through `Month-10`]




```r
for(i in list.files("data")) {
  
* # skip importing file if month value is not 8-10
* month &lt;- as.numeric(stringr::str_extract(i, "\\d+"))
* if(month &lt; 8 | month &gt; 10) next
  
  # steps to import each data set
  df &lt;- readr::read_csv(paste0("data/", i))
  new_name &lt;- stringr::str_sub(i, end = -5)
  assign(new_name, df)
  rm(df)
  
}

# we've only imported months 1-7
ls(pattern = "Month")
## [1] "Month-08" "Month-09" "Month-10"
```

]

---
# `while` loop


---
# `repeat` loop


---
# Summary


---
# Questions
    </textarea>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
